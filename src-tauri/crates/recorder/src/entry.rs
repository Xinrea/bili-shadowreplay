use chrono::{TimeZone, Utc};
use core::fmt;
use std::{fmt::Display, path::Path};
use tokio::{
    fs::OpenOptions,
    io::{AsyncBufReadExt, BufReader},
};

const ENTRY_FILE_NAME: &str = "entries.log";

#[derive(Clone)]
pub struct TsEntry {
    pub url: String,
    pub sequence: u64,
    pub length: f64,
    pub size: u64,
    pub ts: i64,
    pub is_header: bool,
}

impl TsEntry {
    pub fn from(line: &str) -> Result<Self, String> {
        let parts: Vec<&str> = line.split('|').collect();
        if parts.len() != 6 {
            return Err("Invalid input format: expected 6 fields separated by '|'".to_string());
        }
        Ok(TsEntry {
            url: parts[0].to_string(),
            sequence: parts[1]
                .parse()
                .map_err(|e| format!("Failed to parse sequence: {e}"))?,
            length: parts[2]
                .parse()
                .map_err(|e| format!("Failed to parse length: {e}"))?,
            size: parts[3]
                .parse()
                .map_err(|e| format!("Failed to parse size: {e}"))?,
            ts: parts[4]
                .parse()
                .map_err(|e| format!("Failed to parse timestamp: {e}"))?,
            is_header: parts[5]
                .parse()
                .map_err(|e| format!("Failed to parse is_header: {e}"))?,
        })
    }

    /// Get timestamp in seconds
    pub fn ts_seconds(&self) -> i64 {
        // For some legacy problem, douyin entry's ts is s, bilibili entry's ts is ms.
        // This should be fixed after 2.5.6, but we need to support entry.log generated by previous version.
        if self.ts > 10_000_000_000 {
            self.ts / 1000
        } else {
            self.ts
        }
    }

    pub fn date_time(&self) -> String {
        let date_str = Utc
            .timestamp_opt(self.ts_seconds(), 0)
            .unwrap()
            .to_rfc3339();
        format!("#EXT-X-PROGRAM-DATE-TIME:{date_str}\n")
    }

    /// Convert entry into a segment in HLS manifest.
    pub fn to_segment(&self) -> String {
        if self.is_header {
            return String::new();
        }

        let mut content = String::new();

        content += &format!("#EXTINF:{:.4},\n", self.length);
        content += &format!("{}\n", self.url);

        content
    }
}

impl Display for TsEntry {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(
            f,
            "{}|{}|{}|{}|{}|{}",
            self.url, self.sequence, self.length, self.size, self.ts, self.is_header
        )
    }
}

/// `EntryStore` is used to management stream segments, which is basically a simple version of hls manifest,
/// and of course, provides methods to generate hls manifest for frontend player.
pub struct EntryStore {
    header: Option<TsEntry>,
    entries: Vec<TsEntry>,
    total_duration: f64,
    total_size: u64,
    pub last_sequence: u64,
}

impl EntryStore {
    pub async fn new(work_dir: &str) -> Self {
        // if work_dir is not exists, create it
        if !Path::new(work_dir).exists() {
            std::fs::create_dir_all(work_dir).unwrap();
        }

        let mut entry_store = Self {
            header: None,
            entries: vec![],
            total_duration: 0.0,
            total_size: 0,
            last_sequence: 0,
        };

        entry_store.load(work_dir).await;

        entry_store
    }

    async fn load(&mut self, work_dir: &str) {
        let file = OpenOptions::new()
            .create(false)
            .read(true)
            .open(format!("{work_dir}/{ENTRY_FILE_NAME}"))
            .await; // The `file` variable from the previous line now holds `Result<tokio::fs::File, tokio::io::Error>`
        let file_handle = match file {
            Ok(f) => f,
            Err(e) => {
                if e.kind() == std::io::ErrorKind::NotFound {
                    log::info!(
                        "Entry file not found at {work_dir}/{ENTRY_FILE_NAME}, starting fresh."
                    );
                } else {
                    log::error!("Failed to open entry file: {e}");
                }
                return; // Exit the load function if file cannot be opened
            }
        };
        let mut lines = BufReader::new(file_handle).lines();
        while let Ok(Some(line)) = lines.next_line().await {
            let entry = TsEntry::from(line.as_str());
            if let Err(e) = entry {
                log::error!("Failed to parse entry: {e} {line}");
                continue;
            }

            let entry = entry.unwrap();

            self.last_sequence = std::cmp::max(self.last_sequence, entry.sequence);

            if entry.is_header {
                self.header = Some(entry.clone());
            } else {
                self.entries.push(entry.clone());
            }

            self.total_duration += entry.length;
            self.total_size += entry.size;
        }
    }

    pub fn len(&self) -> usize {
        self.entries.len()
    }

    pub fn is_empty(&self) -> bool {
        self.entries.is_empty()
    }

    /// Generate a hls manifest for selected range.
    /// `vod` indicates the manifest is for stream or video.
    /// `force_time` adds DATE-TIME tag for each entry.
    pub fn manifest(&self, vod: bool, force_time: bool, range: Option<Range>) -> String {
        let mut m3u8_content = "#EXTM3U\n".to_string();
        m3u8_content += "#EXT-X-VERSION:6\n";
        m3u8_content += if vod {
            "#EXT-X-PLAYLIST-TYPE:VOD\n"
        } else {
            "#EXT-X-PLAYLIST-TYPE:EVENT\n"
        };
        let end_content = if vod { "#EXT-X-ENDLIST" } else { "" };

        if self.entries.is_empty() {
            m3u8_content += end_content;
            return m3u8_content;
        }

        m3u8_content += &format!(
            "#EXT-X-TARGETDURATION:{}\n",
            (0.5 + self.entries.first().unwrap().length).floor()
        );

        // add header, FMP4 need this
        if let Some(header) = &self.header {
            m3u8_content += &format!("#EXT-X-MAP:URI=\"{}\"\n", header.url);
        }

        // Collect entries in range
        let first_entry = self.entries.first().unwrap();
        let first_entry_ts = first_entry.ts_seconds();
        let mut entries_in_range = vec![];
        for e in &self.entries {
            // ignore header, cause it's already in EXT-X-MAP
            if e.is_header {
                continue;
            }
            let entry_offset = (e.ts_seconds() - first_entry_ts) as f32;
            if range.is_none_or(|r| r.is_in(entry_offset)) {
                entries_in_range.push(e);
            }
        }

        if entries_in_range.is_empty() {
            m3u8_content += end_content;
            log::warn!("No entries in range, return empty manifest");
            return m3u8_content;
        }

        let mut previous_seq = entries_in_range.first().unwrap().sequence;
        for (i, e) in entries_in_range.iter().enumerate() {
            let discontinuous = e.sequence < previous_seq || e.sequence - previous_seq > 1;
            if discontinuous {
                m3u8_content += "#EXT-X-DISCONTINUITY\n";
            }
            // Add date time under these situations.
            if i == 0 || i == entries_in_range.len() - 1 || force_time || discontinuous {
                m3u8_content += &e.date_time();
            }
            m3u8_content += &e.to_segment();

            previous_seq = e.sequence;
        }

        m3u8_content += end_content;
        m3u8_content
    }
}

#[derive(Debug, Clone, Copy)]
pub struct Range {
    pub x: f32,
    pub y: f32,
}

impl Range {
    pub fn is_in(&self, v: f32) -> bool {
        v >= self.x && v <= self.y
    }
}
